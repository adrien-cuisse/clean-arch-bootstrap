{"stats":{"totalMutantsCount":97,"killedCount":39,"notCoveredCount":58,"escapedCount":0,"errorCount":0,"skippedCount":0,"timeOutCount":0,"msi":40.21,"mutationCodeCoverage":40.21,"coveredCodeMsi":100},"escaped":[],"timeouted":[],"killed":[{"mutator":{"mutatorName":"FalseValue","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Email;\n\nfinal class Email implements EmailInterface\n{\n    public function __construct(private string $email)\n    {\n        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === false) {\n            throw new InvalidMailException($this->email);\n        }\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public function __toString() : string\n    {\n        return $this->email;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Email;\n\nfinal class Email implements EmailInterface\n{\n    public function __construct(private string $email)\n    {\n        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === true) {\n            throw new InvalidMailException($this->email);\n        }\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public function __toString() : string\n    {\n        return $this->email;\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Email\/Email.php","originalStartLine":9},"diff":"--- Original\n+++ New\n@@ @@\n {\n     public function __construct(private string $email)\n     {\n-        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === false) {\n+        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === true) {\n             throw new InvalidMailException($this->email);\n         }\n     }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.ebcd7a44e75068bb87c1f69bcd7a09fd.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Email\\EmailTest::rejects_invalid_email\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Email\\InvalidMailException\" is thrown.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"Identical","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Email;\n\nfinal class Email implements EmailInterface\n{\n    public function __construct(private string $email)\n    {\n        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === false) {\n            throw new InvalidMailException($this->email);\n        }\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public function __toString() : string\n    {\n        return $this->email;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Email;\n\nfinal class Email implements EmailInterface\n{\n    public function __construct(private string $email)\n    {\n        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) !== false) {\n            throw new InvalidMailException($this->email);\n        }\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public function __toString() : string\n    {\n        return $this->email;\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Email\/Email.php","originalStartLine":9},"diff":"--- Original\n+++ New\n@@ @@\n {\n     public function __construct(private string $email)\n     {\n-        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === false) {\n+        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) !== false) {\n             throw new InvalidMailException($this->email);\n         }\n     }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.9108517941159f49ae5c7a0fae941519.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Email\\EmailTest::rejects_invalid_email\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Email\\InvalidMailException\" is thrown.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Email;\n\nfinal class Email implements EmailInterface\n{\n    public function __construct(private string $email)\n    {\n        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === false) {\n            throw new InvalidMailException($this->email);\n        }\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public function __toString() : string\n    {\n        return $this->email;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Email;\n\nfinal class Email implements EmailInterface\n{\n    public function __construct(private string $email)\n    {\n        if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === false) {\n            new InvalidMailException($this->email);\n        }\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public function __toString() : string\n    {\n        return $this->email;\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Email\/Email.php","originalStartLine":10},"diff":"--- Original\n+++ New\n@@ @@\n     public function __construct(private string $email)\n     {\n         if (filter_var(value: $this->email, filter: FILTER_VALIDATE_EMAIL) === false) {\n-            throw new InvalidMailException($this->email);\n+            new InvalidMailException($this->email);\n         }\n     }\n     \/**","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.a2b8aabfd7b8fc1d2cb5ea69878028d2.infection.xml\n\nF\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Email\\EmailTest::rejects_invalid_email\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Email\\InvalidMailException\" is thrown.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Email;\n\nuse UnexpectedValueException;\nfinal class InvalidMailException extends UnexpectedValueException\n{\n    public function __construct(private string $email)\n    {\n        parent::__construct(message: \"The mail address '{$this->email}' is invalid\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Email;\n\nuse UnexpectedValueException;\nfinal class InvalidMailException extends UnexpectedValueException\n{\n    public function __construct(private string $email)\n    {\n        \n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Email\/InvalidMailException.php","originalStartLine":11},"diff":"--- Original\n+++ New\n@@ @@\n {\n     public function __construct(private string $email)\n     {\n-        parent::__construct(message: \"The mail address '{$this->email}' is invalid\");\n+        \n     }\n }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.737c98422e8d6aa74433a9bab5b303a4.infection.xml\n\nF                                                                   1 \/ 1 (100%)\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Email\\InvalidMailExceptionTest::shows_email_in_message\nThe exception should store the given mail address in the error message\nFailed asserting that false is not false.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Email\/InvalidMailExceptionTest.php:32\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 3) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":105},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n     {\n-        if (count(value: $timeLowBytes) !== 4) {\n+        if (count(value: $timeLowBytes) !== 3) {\n             throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n         }\n         $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.51608865d0d2f4c6f0b141e852a51077.infection.xml\n\n.F\n\nTime: 00:00.008, Memory: 10.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-mid\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeLowBytesCountException\" matches expected exception \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeMidBytesCountException\". Message was: \"Expected time-low to contain 4 bytes, found [0, 0, 0, 0]\" at\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:83\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 5) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":105},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n     {\n-        if (count(value: $timeLowBytes) !== 4) {\n+        if (count(value: $timeLowBytes) !== 5) {\n             throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n         }\n         $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.ab704cf8bccdc4a59e9341fb48cec595.infection.xml\n\n.F\n\nTime: 00:00.008, Memory: 10.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-mid\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeLowBytesCountException\" matches expected exception \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeMidBytesCountException\". Message was: \"Expected time-low to contain 4 bytes, found [0, 0, 0, 0]\" at\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:83\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"NotIdentical","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) === 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":105},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n     {\n-        if (count(value: $timeLowBytes) !== 4) {\n+        if (count(value: $timeLowBytes) === 4) {\n             throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n         }\n         $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.9ca9912b90f8506d8725ff78c2098920.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-low\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeLowBytesCountException\" is thrown.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":106},"diff":"--- Original\n+++ New\n@@ @@\n     protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n     {\n         if (count(value: $timeLowBytes) !== 4) {\n-            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n+            new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n         }\n         $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n         if (count(value: $timeMidBytes) !== 2) {","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.ecd35a98f5ca9aac19f47289ce4220ec.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-low\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeLowBytesCountException\" is thrown.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 1) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":110},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n         }\n         $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n-        if (count(value: $timeMidBytes) !== 2) {\n+        if (count(value: $timeMidBytes) !== 1) {\n             throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n         }\n         $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.af6feb9204d69f79ccd4aa6ff69542fc.infection.xml\n\n..F\n\nTime: 00:00.008, Memory: 10.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-high\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeMidBytesCountException\" matches expected exception \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeHighBytesCountException\". Message was: \"Expected time-mid to contain 2 bytes, found [0, 0]\" at\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:87\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n.\n\nFAILURES!\nTests: 3, Assertions: 3, Failures: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 3) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":110},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n         }\n         $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n-        if (count(value: $timeMidBytes) !== 2) {\n+        if (count(value: $timeMidBytes) !== 3) {\n             throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n         }\n         $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.d65fdd9f6c37dfc81b24d5ea15e58d62.infection.xml\n\n..F\n\nTime: 00:00.009, Memory: 10.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-high\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeMidBytesCountException\" matches expected exception \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeHighBytesCountException\". Message was: \"Expected time-mid to contain 2 bytes, found [0, 0]\" at\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:87\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n.\n\nFAILURES!\nTests: 3, Assertions: 3, Failures: 1."},{"mutator":{"mutatorName":"NotIdentical","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) === 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":110},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n         }\n         $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n-        if (count(value: $timeMidBytes) !== 2) {\n+        if (count(value: $timeMidBytes) === 2) {\n             throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n         }\n         $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.1a1f37eb9ac9ec834c9db0f4a3625bbe.infection.xml\n\n.F\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-mid\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeMidBytesCountException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":111},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n         if (count(value: $timeMidBytes) !== 2) {\n-            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n+            new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n         }\n         $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n         if (count(value: $timeHighBytes) !== 2) {","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.30b53c84be363611eba718dffb44e977.infection.xml\n\n.F\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-mid\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeMidBytesCountException\" is thrown.\n\nFAILURES!\nTests: 2, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 1) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":115},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n         }\n         $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n-        if (count(value: $timeHighBytes) !== 2) {\n+        if (count(value: $timeHighBytes) !== 1) {\n             throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n         }\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.58811e1a8d6eee390274ed618f6b47ac.infection.xml\n\n...F\n\nTime: 00:00.008, Memory: 10.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"node\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeHighBytesCountException\" matches expected exception \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidNodeBytesCountException\". Message was: \"Expected time-high to contain 2 bytes, found [0, 0]\" at\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:91\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n.\n\nFAILURES!\nTests: 4, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 3) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":115},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n         }\n         $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n-        if (count(value: $timeHighBytes) !== 2) {\n+        if (count(value: $timeHighBytes) !== 3) {\n             throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n         }\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.8cfe4cc84ca7118153fae0f13f01e180.infection.xml\n\n...F\n\nTime: 00:00.008, Memory: 10.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"node\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeHighBytesCountException\" matches expected exception \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidNodeBytesCountException\". Message was: \"Expected time-high to contain 2 bytes, found [0, 0]\" at\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:91\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n.\n\nFAILURES!\nTests: 4, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"NotIdentical","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) === 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":115},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n         }\n         $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n-        if (count(value: $timeHighBytes) !== 2) {\n+        if (count(value: $timeHighBytes) === 2) {\n             throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n         }\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.963ee9be25c542e88a44406f8055e6d1.infection.xml\n\n..E\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-high\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nUndefined array key 0\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:94\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n\nERRORS!\nTests: 3, Assertions: 2, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":116},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n         if (count(value: $timeHighBytes) !== 2) {\n-            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n+            new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n         }\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n         $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.9ba9094459d14889ddd387713e1474db.infection.xml\n\n..E\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-high\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nUndefined array key 0\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:94\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n\nERRORS!\nTests: 3, Assertions: 2, Errors: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[1] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":119},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n         }\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n-        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n+        $this->timeHighBytes[1] &= self::TIME_HIGH_MSB_MASK;\n         if ($version > 0b1111) {\n             throw new InvalidUuidVersionException(version: $version);\n         }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.29c480911a7a3cc2176429905926ed58.infection.xml\n\n.........F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::clamps_time_high_most_significant_byte_to_4_bits\nExpected time-high MSB to get clamped to 4 bits\nFailed asserting that 255 is identical to 15.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:200\n\nFAILURES!\nTests: 10, Assertions: 10, Failures: 1."},{"mutator":{"mutatorName":"Assignment","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] = self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":119},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n         }\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n-        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n+        $this->timeHighBytes[0] = self::TIME_HIGH_MSB_MASK;\n         if ($version > 0b1111) {\n             throw new InvalidUuidVersionException(version: $version);\n         }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.c8310ae058c4a459838af007d2a5df1a.infection.xml\n\n.......F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::clamps_to_bytes with data set \"time-high\" (array(array(16903, 16904)), array(7, 8), 'timeHighBytes')\nExpected property timeHighBytes to be clamped to [7, 8], got [15, 8]\nFailed asserting that two arrays are identical.\n--- Expected\n+++ Actual\n@@ @@\n Array &0 (\n-    0 => 7\n+    0 => 15\n     1 => 8\n )\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:179\n\nFAILURES!\nTests: 8, Assertions: 8, Failures: 1."},{"mutator":{"mutatorName":"GreaterThan","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version >= 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":121},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n         $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n-        if ($version > 0b1111) {\n+        if ($version >= 0b1111) {\n             throw new InvalidUuidVersionException(version: $version);\n         }\n         $this->version = $version;","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.f2d73cbfca50f6e32aa894a76845f59e.infection.xml\n\n...............E\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::puts_byte_at_correct_position with data set \"time-low-0\" (array(15, array(0, 1, 2, 3), array(4, 5), array(6, 7), 8, 9, array(10, 11, 12, 13, 14, 15)), 'time-low-0', 0, 0)\nAlphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidVersionException: Version 15 is invalid, it may not exceed 15\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:96\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:643\n\nERRORS!\nTests: 16, Assertions: 15, Errors: 1."},{"mutator":{"mutatorName":"GreaterThanNegotiation","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version <= 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":121},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n         $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n-        if ($version > 0b1111) {\n+        if ($version <= 0b1111) {\n             throw new InvalidUuidVersionException(version: $version);\n         }\n         $this->version = $version;","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.8251b428decefe6418602b1df2ae688b.infection.xml\n\n...F\n\nTime: 00:00.008, Memory: 10.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"node\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidVersionException\" matches expected exception \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidNodeBytesCountException\". Message was: \"Version 0 is invalid, it may not exceed 15\" at\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:96\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n.\n\nFAILURES!\nTests: 4, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":122},"diff":"--- Original\n+++ New\n@@ @@\n         $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n         $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n         if ($version > 0b1111) {\n-            throw new InvalidUuidVersionException(version: $version);\n+            new InvalidUuidVersionException(version: $version);\n         }\n         $this->version = $version;\n         $this->versionBits = $this->version << 4;","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.0d7308e79be7a05de4588f111cdf0213.infection.xml\n\n....F\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::expects_4_bits_version\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidVersionException\" is thrown.\n\nFAILURES!\nTests: 5, Assertions: 5, Failures: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 3;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":125},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidVersionException(version: $version);\n         }\n         $this->version = $version;\n-        $this->versionBits = $this->version << 4;\n+        $this->versionBits = $this->version << 3;\n         $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n         $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n         if (count(value: $nodeBytes) !== 6) {","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.76729790c80594ef003e8b27273352d1.infection.xml\n\n..........F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_version_in_time_high_MSB\nUuid should interlop version in time-high MSB\nFailed asserting that 42 is identical to 90.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:223\n\nFAILURES!\nTests: 11, Assertions: 11, Failures: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 5;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":125},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidVersionException(version: $version);\n         }\n         $this->version = $version;\n-        $this->versionBits = $this->version << 4;\n+        $this->versionBits = $this->version << 5;\n         $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n         $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n         if (count(value: $nodeBytes) !== 6) {","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.2c84b656580de5e9ba2fb92ea2b6b402.infection.xml\n\n..........F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_version_in_time_high_MSB\nUuid should interlop version in time-high MSB\nFailed asserting that 170 is identical to 90.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:223\n\nFAILURES!\nTests: 11, Assertions: 11, Failures: 1."},{"mutator":{"mutatorName":"ShiftLeft","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version >> 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":125},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidUuidVersionException(version: $version);\n         }\n         $this->version = $version;\n-        $this->versionBits = $this->version << 4;\n+        $this->versionBits = $this->version >> 4;\n         $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n         $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n         if (count(value: $nodeBytes) !== 6) {","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.d9a45125f0af49114124b17f33b90ba9.infection.xml\n\n..........F\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_version_in_time_high_MSB\nUuid should interlop version in time-high MSB\nFailed asserting that 10 is identical to 90.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:223\n\nFAILURES!\nTests: 11, Assertions: 11, Failures: 1."},{"mutator":{"mutatorName":"BitwiseAnd","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte | self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":127},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $this->version = $version;\n         $this->versionBits = $this->version << 4;\n-        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n+        $this->clockSeqHighBits = $clockSeqHighByte | self::CLOCK_SEQ_HIGH_MASK;\n         $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n         if (count(value: $nodeBytes) !== 6) {\n             throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.0b6fed2cdcb80ac598eea6c78fcda489.infection.xml\n\n...........F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::clamps_clock_seq_high_to_6_bits\nExpected clock-seq-high to get clamped to 6 bits\nFailed asserting that 255 is identical to 63.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:243\n\nFAILURES!\nTests: 12, Assertions: 12, Failures: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 5) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":130},"diff":"--- Original\n+++ New\n@@ @@\n         $this->versionBits = $this->version << 4;\n         $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n         $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n-        if (count(value: $nodeBytes) !== 6) {\n+        if (count(value: $nodeBytes) !== 5) {\n             throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n         }\n         $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.28482b0bda83f4b72fdcfb5fe10a412d.infection.xml\n\n.....E\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::clamps_to_bytes with data set \"time-low\" (array(array(16897, 16898, 16899, 16900)), array(1, 2, 3, 4), 'timeLowBytes')\nAlphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidNodeBytesCountException: Expected node to contain 6 bytes, found [0, 0, 0, 0, 0, 0]\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:103\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:167\n\nERRORS!\nTests: 6, Assertions: 5, Errors: 1."},{"mutator":{"mutatorName":"NotIdentical","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) === 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":130},"diff":"--- Original\n+++ New\n@@ @@\n         $this->versionBits = $this->version << 4;\n         $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n         $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n-        if (count(value: $nodeBytes) !== 6) {\n+        if (count(value: $nodeBytes) === 6) {\n             throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n         }\n         $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.c67b28d5cb4d6a5e566d3e0b9e0e9cf2.infection.xml\n\n...F\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"node\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidNodeBytesCountException\" is thrown.\n\nFAILURES!\nTests: 4, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 7) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":130},"diff":"--- Original\n+++ New\n@@ @@\n         $this->versionBits = $this->version << 4;\n         $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n         $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n-        if (count(value: $nodeBytes) !== 6) {\n+        if (count(value: $nodeBytes) !== 7) {\n             throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n         }\n         $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.166e65c3e9e11612fc0d491400d16462.infection.xml\n\n.....E\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::clamps_to_bytes with data set \"time-low\" (array(array(16897, 16898, 16899, 16900)), array(1, 2, 3, 4), 'timeLowBytes')\nAlphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidNodeBytesCountException: Expected node to contain 6 bytes, found [0, 0, 0, 0, 0, 0]\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:103\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:67\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:49\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:167\n\nERRORS!\nTests: 6, Assertions: 5, Errors: 1."},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":131},"diff":"--- Original\n+++ New\n@@ @@\n         $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n         $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n         if (count(value: $nodeBytes) !== 6) {\n-            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n+            new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n         }\n         $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n     }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.a006937eb19897d2bbab137c49d6cafa.infection.xml\n\n...F\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"node\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidNodeBytesCountException\" is thrown.\n\nFAILURES!\nTests: 4, Assertions: 4, Failures: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":151},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public final function toRfcUuidString() : string\n     {\n-        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n+        $versionAndTimeHighBytes = [$this->timeHighBytes[1]];\n         $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n         return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n     }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.3fd66b9fa56764d999353dd11096849f.infection.xml\n\n..........F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_version_in_time_high_MSB\nUuid should interlop version in time-high MSB\nFailed asserting that 16 is identical to 90.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:223\n\nFAILURES!\nTests: 11, Assertions: 11, Failures: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[1], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":152},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public final function toRfcUuidString() : string\n     {\n-        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n+        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[1], $this->timeHighBytes[1]];\n         $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n         return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n     }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.eddf07daecf6161a19492bfd72202175.infection.xml\n\n..........F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_version_in_time_high_MSB\nUuid should interlop version in time-high MSB\nFailed asserting that 80 is identical to 90.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:223\n\nFAILURES!\nTests: 11, Assertions: 11, Failures: 1."},{"mutator":{"mutatorName":"BitwiseOr","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits & $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":152},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public final function toRfcUuidString() : string\n     {\n-        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n+        $versionAndTimeHighBytes = [$this->versionBits & $this->timeHighBytes[0], $this->timeHighBytes[1]];\n         $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n         return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n     }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.79f09484bf72d136d0bad2dd6bdb0d46.infection.xml\n\n..........F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_version_in_time_high_MSB\nUuid should interlop version in time-high MSB\nFailed asserting that 0 is identical to 90.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:223\n\nFAILURES!\nTests: 11, Assertions: 11, Failures: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[0]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":153},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public final function toRfcUuidString() : string\n     {\n-        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n+        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[0]];\n         $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n         return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n     }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.156f22f8ff85907e631e3901dddf2c45.infection.xml\n\n......................F\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::puts_byte_at_correct_position with data set \"time-high-1\" (array(15, array(0, 1, 2, 3), array(4, 5), array(6, 7), 8, 9, array(10, 11, 12, 13, 14, 15)), 'time-high-1', 7, 16)\nExpected time-high-1 (7) to be at position 16 in string 00010203-0405-f606-8809-0a0b0c0d0e0f, found 06 (6)\nFailed asserting that 6 is identical to 7.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:654\n\nFAILURES!\nTests: 23, Assertions: 23, Failures: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[2]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":153},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public final function toRfcUuidString() : string\n     {\n-        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n+        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[2]];\n         $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n         return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n     }","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.b67512aa9dd542d00eb6d19de6d946a5.infection.xml\n\n..........E\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_version_in_time_high_MSB\nUndefined array key 2\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:121\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:130\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:216\n\nERRORS!\nTests: 11, Assertions: 10, Errors: 1."},{"mutator":{"mutatorName":"BitwiseOr","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS & $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":156},"diff":"--- Original\n+++ New\n@@ @@\n     public final function toRfcUuidString() : string\n     {\n         $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n-        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n+        $variantAndclockSeqHighByte = self::VARIANT_BITS & $this->clockSeqHighBits;\n         return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n     }\n     \/**","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.389f807ef67ce4d4c0c528a4449eb294.infection.xml\n\n............F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_variant_in_clock_seq_high\nUuid should interlop variant in clock-seq-high\nFailed asserting that 0 is identical to 191.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:266\n\nFAILURES!\nTests: 13, Assertions: 13, Failures: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: []), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":163},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n         $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n-        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n+        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: []), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n     }\n     \/**\n      * @see Stringable","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.d2f1e316609d51a8fdf58ed8604a3fa7.infection.xml\n\n............F\n\nTime: 00:00.006, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::interlops_variant_in_clock_seq_high\nUuid should interlop variant in clock-seq-high\nFailed asserting that 0 is identical to 191.\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:266\n\nFAILURES!\nTests: 13, Assertions: 13, Failures: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: []), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":164},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n         $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n-        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n+        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: []), $this->hexaStringFrom(bytes: $this->nodeBytes));\n     }\n     \/**\n      * @see Stringable","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.8e7794cd90a031f9abe0a506528a792c.infection.xml\n\n.............F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::has_rfc_compliant_representation\nThe UUID doesn't comply with RFC representation 01234567-89ab-cdef-0123-456789abcdef\nFailed asserting that '00000000-0000-0000-80-000000000000' matches PCRE pattern \"\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/\".\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:295\n\nFAILURES!\nTests: 14, Assertions: 14, Failures: 1."},{"mutator":{"mutatorName":"BitwiseAnd","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value | self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":249},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     private function clampToByte(int $value) : int\n     {\n-        return $value & self::BYTE_MASK;\n+        return $value | self::BYTE_MASK;\n     }\n     \/**\n      * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.1f00d79614feafc42de9d9c185b1d8b2.infection.xml\n\n.....F\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::clamps_to_bytes with data set \"time-low\" (array(array(16897, 16898, 16899, 16900)), array(1, 2, 3, 4), 'timeLowBytes')\nExpected property timeLowBytes to be clamped to [1, 2, 3, 4], got [17151, 17151, 17151, 17151]\nFailed asserting that two arrays are identical.\n--- Expected\n+++ Actual\n@@ @@\n Array &0 (\n-    0 => 1\n-    1 => 2\n-    2 => 3\n-    3 => 4\n+    0 => 17151\n+    1 => 17151\n+    2 => 17151\n+    3 => 17151\n )\n\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:179\n\nFAILURES!\nTests: 6, Assertions: 6, Failures: 1."},{"mutator":{"mutatorName":"UnwrapArrayMap","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array: $integers;\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":261},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     private function clampToBytes(array $integers) : array\n     {\n-        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n+        return array: $integers;\n     }\n     \/**\n      * Writes the given bytes in an hexadecimal string","processOutput":"PHPUnit 9.5.6 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.8\nConfiguration: \/tmp\/infection\/phpunitConfiguration.78ecd5f61e1cd13aa790eb37e1942192.infection.xml\n\nF\n\nTime: 00:00.008, Memory: 10.00 MB\n\nThere was 1 failure:\n\n1) Alphonse\\CleanArch\\Tests\\Domain\\Fields\\Identity\\UuidTest::rejects_invalid_bytes_count with data set \"time-low\" (array(array()), 'Alphonse\\CleanArch\\Domain\\Fie...eption')\nFailed asserting that exception of type \"ParseError\" matches expected exception \"Alphonse\\CleanArch\\Domain\\Fields\\Identity\\InvalidUuidTimeLowBytesCountException\". Message was: \"syntax error, unexpected token \":\", expecting \"(\"\" at\n\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php:195\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:48\n\/home\/arch\/src\/web-project\/clean-arch-example\/tests\/Domain\/Fields\/Identity\/UuidTest.php:113\n.\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."}],"errored":[],"uncovered":[{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse LengthException;\nfinal class InvalidUuidNodeBytesCountException extends LengthException\n{\n    public function __construct(array $bytes)\n    {\n        parent::__construct(sprintf(\"Expected node to contain 6 bytes, found [%s]\", implode(', ', $bytes)));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse LengthException;\nfinal class InvalidUuidNodeBytesCountException extends LengthException\n{\n    public function __construct(array $bytes)\n    {\n        \n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/InvalidUuidNodeBytesCountException.php","originalStartLine":11},"diff":"--- Original\n+++ New\n@@ @@\n {\n     public function __construct(array $bytes)\n     {\n-        parent::__construct(sprintf(\"Expected node to contain 6 bytes, found [%s]\", implode(', ', $bytes)));\n+        \n     }\n }","processOutput":""},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse LengthException;\nfinal class InvalidUuidTimeHighBytesCountException extends LengthException\n{\n    public function __construct(array $bytes)\n    {\n        parent::__construct(sprintf(\"Expected time-high to contain 2 bytes, found [%s]\", implode(', ', $bytes)));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse LengthException;\nfinal class InvalidUuidTimeHighBytesCountException extends LengthException\n{\n    public function __construct(array $bytes)\n    {\n        \n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/InvalidUuidTimeHighBytesCountException.php","originalStartLine":11},"diff":"--- Original\n+++ New\n@@ @@\n {\n     public function __construct(array $bytes)\n     {\n-        parent::__construct(sprintf(\"Expected time-high to contain 2 bytes, found [%s]\", implode(', ', $bytes)));\n+        \n     }\n }","processOutput":""},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse LengthException;\nfinal class InvalidUuidTimeLowBytesCountException extends LengthException\n{\n    public function __construct(array $bytes)\n    {\n        parent::__construct(sprintf(\"Expected time-low to contain 4 bytes, found [%s]\", implode(', ', $bytes)));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse LengthException;\nfinal class InvalidUuidTimeLowBytesCountException extends LengthException\n{\n    public function __construct(array $bytes)\n    {\n        \n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/InvalidUuidTimeLowBytesCountException.php","originalStartLine":11},"diff":"--- Original\n+++ New\n@@ @@\n {\n     public function __construct(array $bytes)\n     {\n-        parent::__construct(sprintf(\"Expected time-low to contain 4 bytes, found [%s]\", implode(', ', $bytes)));\n+        \n     }\n }","processOutput":""},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse LengthException;\nfinal class InvalidUuidTimeMidBytesCountException extends LengthException\n{\n    public function __construct(array $bytes)\n    {\n        parent::__construct(sprintf(\"Expected time-mid to contain 2 bytes, found [%s]\", implode(', ', $bytes)));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse LengthException;\nfinal class InvalidUuidTimeMidBytesCountException extends LengthException\n{\n    public function __construct(array $bytes)\n    {\n        \n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/InvalidUuidTimeMidBytesCountException.php","originalStartLine":11},"diff":"--- Original\n+++ New\n@@ @@\n {\n     public function __construct(array $bytes)\n     {\n-        parent::__construct(sprintf(\"Expected time-mid to contain 2 bytes, found [%s]\", implode(', ', $bytes)));\n+        \n     }\n }","processOutput":""},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse OverflowException;\nfinal class InvalidUuidVersionException extends OverflowException\n{\n    public function __construct(int $version)\n    {\n        parent::__construct(\"Version {$version} is invalid, it may not exceed 15\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse OverflowException;\nfinal class InvalidUuidVersionException extends OverflowException\n{\n    public function __construct(int $version)\n    {\n        \n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/InvalidUuidVersionException.php","originalStartLine":11},"diff":"--- Original\n+++ New\n@@ @@\n {\n     public function __construct(int $version)\n     {\n-        parent::__construct(\"Version {$version} is invalid, it may not exceed 15\");\n+        \n     }\n }","processOutput":""},{"mutator":{"mutatorName":"PregMatchRemoveCaret","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match('\/[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":186},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected static function fromString(string $rfcUuidString) : static\n     {\n-        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n+        if (preg_match('\/[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n         }\n         $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);","processOutput":""},{"mutator":{"mutatorName":"PregMatchRemoveDollar","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match('\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":186},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected static function fromString(string $rfcUuidString) : static\n     {\n-        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n+        if (preg_match('\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}\/', subject: $rfcUuidString) !== 1) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n         }\n         $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 2) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":186},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected static function fromString(string $rfcUuidString) : static\n     {\n-        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n+        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 2) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n         }\n         $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);","processOutput":""},{"mutator":{"mutatorName":"NotIdentical","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) === 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":186},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected static function fromString(string $rfcUuidString) : static\n     {\n-        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n+        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) === 1) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n         }\n         $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);","processOutput":""},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":187},"diff":"--- Original\n+++ New\n@@ @@\n     protected static function fromString(string $rfcUuidString) : static\n     {\n         if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n-            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n+            new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n         }\n         $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n         $binaryString = hex2bin(string: $hexaString);","processOutput":""},{"mutator":{"mutatorName":"UnwrapStrReplace","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = subject: $rfcUuidString;\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":190},"diff":"--- Original\n+++ New\n@@ @@\n         if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n         }\n-        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n+        $hexaString = subject: $rfcUuidString;\n         $binaryString = hex2bin(string: $hexaString);\n         $bytes = str_split(string: $binaryString);\n         $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);","processOutput":""},{"mutator":{"mutatorName":"UnwrapArrayMap","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array: $bytes;\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":194},"diff":"--- Original\n+++ New\n@@ @@\n         $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n         $binaryString = hex2bin(string: $hexaString);\n         $bytes = str_split(string: $binaryString);\n-        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n+        $bytes = array: $bytes;\n         $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n         if ($instance->getVersion() != $rfcUuidString[14]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[13]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":201},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes = str_split(string: $binaryString);\n         $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n         $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n-        if ($instance->getVersion() != $rfcUuidString[14]) {\n+        if ($instance->getVersion() != $rfcUuidString[13]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[15]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":201},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes = str_split(string: $binaryString);\n         $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n         $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n-        if ($instance->getVersion() != $rfcUuidString[14]) {\n+        if ($instance->getVersion() != $rfcUuidString[15]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);","processOutput":""},{"mutator":{"mutatorName":"NotEqual","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() == $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":201},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes = str_split(string: $binaryString);\n         $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n         $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n-        if ($instance->getVersion() != $rfcUuidString[14]) {\n+        if ($instance->getVersion() == $rfcUuidString[14]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);","processOutput":""},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":202},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n         $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n         if ($instance->getVersion() != $rfcUuidString[14]) {\n-            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n+            new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: -1, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":205},"diff":"--- Original\n+++ New\n@@ @@\n         if ($instance->getVersion() != $rfcUuidString[14]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n-        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n+        $instance->timeLowBytes = array_slice(array: $bytes, offset: -1, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 1, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":205},"diff":"--- Original\n+++ New\n@@ @@\n         if ($instance->getVersion() != $rfcUuidString[14]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n-        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n+        $instance->timeLowBytes = array_slice(array: $bytes, offset: 1, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 3);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":205},"diff":"--- Original\n+++ New\n@@ @@\n         if ($instance->getVersion() != $rfcUuidString[14]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n-        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n+        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 3);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 5);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":205},"diff":"--- Original\n+++ New\n@@ @@\n         if ($instance->getVersion() != $rfcUuidString[14]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n-        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n+        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 5);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;","processOutput":""},{"mutator":{"mutatorName":"UnwrapArraySlice","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array: $bytes;\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":205},"diff":"--- Original\n+++ New\n@@ @@\n         if ($instance->getVersion() != $rfcUuidString[14]) {\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n-        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n+        $instance->timeLowBytes = array: $bytes;\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 3, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":206},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n-        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n+        $instance->timeMidBytes = array_slice(array: $bytes, offset: 3, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 5, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":206},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n-        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n+        $instance->timeMidBytes = array_slice(array: $bytes, offset: 5, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 1);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":206},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n-        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n+        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 1);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 3);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":206},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n-        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n+        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 3);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);","processOutput":""},{"mutator":{"mutatorName":"UnwrapArraySlice","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array: $bytes;\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":206},"diff":"--- Original\n+++ New\n@@ @@\n             throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n-        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n+        $instance->timeMidBytes = array: $bytes;\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[5] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":208},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n-        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n+        $instance->versionBits = ($bytes[5] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[7] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":208},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n-        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n+        $instance->versionBits = ($bytes[7] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;","processOutput":""},{"mutator":{"mutatorName":"BitwiseAnd","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] | self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":208},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n-        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n+        $instance->versionBits = ($bytes[6] | self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 3;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":208},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n-        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n+        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 3;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 5;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":208},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n-        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n+        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 5;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;","processOutput":""},{"mutator":{"mutatorName":"ShiftRight","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) << 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":208},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n-        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n+        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) << 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[5] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":209},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n-        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n+        $bytes[5] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[7] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":209},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n-        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n+        $bytes[7] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[5] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":209},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n-        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n+        $bytes[6] = $bytes[5] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[7] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":209},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n-        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n+        $bytes[6] = $bytes[7] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];","processOutput":""},{"mutator":{"mutatorName":"BitwiseAnd","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] | self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":209},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n-        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n+        $bytes[6] = $bytes[6] | self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 5, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":211},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n-        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n+        $instance->timeHighBytes = array_slice(array: $bytes, offset: 5, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 7, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":211},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n-        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n+        $instance->timeHighBytes = array_slice(array: $bytes, offset: 7, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 1);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":211},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n-        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n+        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 1);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 3);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":211},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n-        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n+        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 3);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];","processOutput":""},{"mutator":{"mutatorName":"UnwrapArraySlice","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array: $bytes;\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":211},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n-        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n+        $instance->timeHighBytes = array: $bytes;\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[7] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":213},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n-        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n+        $bytes[7] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[9] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":213},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n-        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n+        $bytes[9] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[7] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":213},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n-        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n+        $bytes[8] = $bytes[7] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[9] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":213},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n-        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n+        $bytes[8] = $bytes[9] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);","processOutput":""},{"mutator":{"mutatorName":"BitwiseAnd","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] | self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":213},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n-        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n+        $bytes[8] = $bytes[8] | self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[7];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":215},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n-        $instance->clockSeqHighBits = $bytes[8];\n+        $instance->clockSeqHighBits = $bytes[7];\n         $instance->clockSeqLowByte = $bytes[9];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n         return $instance;","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[9];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":215},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n-        $instance->clockSeqHighBits = $bytes[8];\n+        $instance->clockSeqHighBits = $bytes[9];\n         $instance->clockSeqLowByte = $bytes[9];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n         return $instance;","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[8];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":216},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n-        $instance->clockSeqLowByte = $bytes[9];\n+        $instance->clockSeqLowByte = $bytes[8];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n         return $instance;\n     }","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[10];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":216},"diff":"--- Original\n+++ New\n@@ @@\n         $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n-        $instance->clockSeqLowByte = $bytes[9];\n+        $instance->clockSeqLowByte = $bytes[10];\n         $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n         return $instance;\n     }","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 9, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":218},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n-        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n+        $instance->nodeBytes = array_slice(array: $bytes, offset: 9, length: 6);\n         return $instance;\n     }\n     \/**","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 11, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":218},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n-        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n+        $instance->nodeBytes = array_slice(array: $bytes, offset: 11, length: 6);\n         return $instance;\n     }\n     \/**","processOutput":""},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 5);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":218},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n-        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n+        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 5);\n         return $instance;\n     }\n     \/**","processOutput":""},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 7);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":218},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n-        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n+        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 7);\n         return $instance;\n     }\n     \/**","processOutput":""},{"mutator":{"mutatorName":"UnwrapArraySlice","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array: $bytes;\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":218},"diff":"--- Original\n+++ New\n@@ @@\n         $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n         $instance->clockSeqHighBits = $bytes[8];\n         $instance->clockSeqLowByte = $bytes[9];\n-        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n+        $instance->nodeBytes = array: $bytes;\n         return $instance;\n     }\n     \/**","processOutput":""},{"mutator":{"mutatorName":"UnwrapArrayMap","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array: str_split($binaryString);\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":234},"diff":"--- Original\n+++ New\n@@ @@\n     protected final function randomBytes(int $numberOfBytes) : array\n     {\n         $binaryString = random_bytes(length: $numberOfBytes);\n-        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n+        return array: str_split($binaryString);\n     }\n     \/**\n      * Removes overflowing bits from the given value","processOutput":""},{"mutator":{"mutatorName":"BitwiseAnd","originalSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Alphonse\\CleanArch\\Domain\\Fields\\Identity;\n\nuse ReflectionClass;\nuse InvalidArgumentException;\n\/**\n * @see UuidInterface\n *\/\nabstract class Uuid implements UuidInterface\n{\n    \/**\n     * The variant used\n     * @link https:\/\/datatracker.ietf.org\/doc\/html\/rfc4122#section-4.1.1\n     *\/\n    private const VARIANT = 0b10;\n    \/**\n     * Variant bits, will be multiplexed with the clock-seq-high bits\n     *\/\n    private const VARIANT_BITS = self::VARIANT << 6;\n    \/**\n     * Bit-mask to clamp an integer to byte-range\n     *\/\n    private const BYTE_MASK = 0b11111111;\n    \/**\n     * Bit-mask to extract the 4 least significant bits from a byte\n     *\/\n    private const LOWEST_4_BITS_MASK = 0b1111;\n    \/**\n     * Bit-mask to extract the 4 most significant bits from a byte\n     *\/\n    private const HIGHEST_4_BITS_MASK = 0b11110000;\n    \/**\n     * Bit-maks to apply on the most significant byte of the time-high-bytes, removes its 4 highest bits\n     *\/\n    private const TIME_HIGH_MSB_MASK = self::LOWEST_4_BITS_MASK;\n    \/**\n     * Bit-mask to remove the 2 most significant bits from the clock-seq-high byte\n     *\/\n    private const CLOCK_SEQ_HIGH_MASK = 0b111111;\n    \/**\n     * @var int[] - bytes 0 to 3\n     *\/\n    private array $timeLowBytes;\n    \/**\n     * @var int[] - bytes 4 to 5\n     *\/\n    private array $timeMidBytes;\n    \/**\n     * @var int - the version of the Uuid\n     *\/\n    private int $version;\n    \/**\n     * @var int - 4 most significant bits of the byte 6\n     *\/\n    private int $versionBits;\n    \/**\n     * @var int[] - 4 least significant bits of byte 6, byte 7\n     *\/\n    private array $timeHighBytes;\n    \/**\n     * @var int - 6 least significants bits of byte 8\n     *\/\n    private int $clockSeqHighBits;\n    \/**\n     * @var int - byte 9\n     *\/\n    private int $clockSeqLowByte;\n    \/**\n     * @var int[] - bytes 10 to 15\n     *\/\n    private array $nodeBytes;\n    \/**\n     * @throws InvalidUuidTimeLowBytesCountException - if the number of time-low bytes is invalid\n     * @throws InvalidUuidTimeMidBytesCountException - if the number of time-mid bytes is invalid\n     * @throws InvalidUuidTimeHighBytesCountException - if the number of time-high bytes is invalid\n     * @throws InvalidUuidVersionException - if the version exceeds 15\n     * @throws InvalidUuidNodeBytesCountException - if the number of node bytes is invalid\n     *\/\n    protected function __construct(int $version, array $timeLowBytes, array $timeMidBytes, array $timeHighBytes, int $clockSeqHighByte, int $clockSeqLowByte, array $nodeBytes)\n    {\n        if (count(value: $timeLowBytes) !== 4) {\n            throw new InvalidUuidTimeLowBytesCountException(bytes: $timeLowBytes);\n        }\n        $this->timeLowBytes = $this->clampToBytes(integers: $timeLowBytes);\n        if (count(value: $timeMidBytes) !== 2) {\n            throw new InvalidUuidTimeMidBytesCountException(bytes: $timeMidBytes);\n        }\n        $this->timeMidBytes = $this->clampToBytes(integers: $timeMidBytes);\n        if (count(value: $timeHighBytes) !== 2) {\n            throw new InvalidUuidTimeHighBytesCountException(bytes: $timeHighBytes);\n        }\n        $this->timeHighBytes = $this->clampToBytes(integers: $timeHighBytes);\n        $this->timeHighBytes[0] &= self::TIME_HIGH_MSB_MASK;\n        if ($version > 0b1111) {\n            throw new InvalidUuidVersionException(version: $version);\n        }\n        $this->version = $version;\n        $this->versionBits = $this->version << 4;\n        $this->clockSeqHighBits = $clockSeqHighByte & self::CLOCK_SEQ_HIGH_MASK;\n        $this->clockSeqLowByte = $this->clampToByte(value: $clockSeqLowByte);\n        if (count(value: $nodeBytes) !== 6) {\n            throw new InvalidUuidNodeBytesCountException(bytes: $nodeBytes);\n        }\n        $this->nodeBytes = $this->clampToBytes(integers: $nodeBytes);\n    }\n    \/**\n     * @see UuidInterface\n     *\/\n    public final function getVersion() : int\n    {\n        return $this->version;\n    }\n    \/**\n     * Puts all bits in the right place and generates the string representation\n     *\n     * @see UuidInterface\n     *\/\n    public final function toRfcUuidString() : string\n    {\n        $versionAndTimeHighBytes = [$this->versionBits | $this->timeHighBytes[0], $this->timeHighBytes[1]];\n        $variantAndclockSeqHighByte = self::VARIANT_BITS | $this->clockSeqHighBits;\n        return sprintf(\"%s-%s-%s-%s%s-%s\", $this->hexaStringFrom(bytes: $this->timeLowBytes), $this->hexaStringFrom(bytes: $this->timeMidBytes), $this->hexaStringFrom(bytes: $versionAndTimeHighBytes), $this->hexaStringFrom(bytes: [$variantAndclockSeqHighByte]), $this->hexaStringFrom(bytes: [$this->clockSeqLowByte]), $this->hexaStringFrom(bytes: $this->nodeBytes));\n    }\n    \/**\n     * @see Stringable\n     *\/\n    public final function __toString() : string\n    {\n        return $this->toRfcUuidString();\n    }\n    \/**\n     * Creates an UUID from a RFC representation string\n     *\n     * @param string $rfcUuidString - the RFC representation to build the Uuid from\n     *\n     * @return static\n     *\/\n    protected static function fromString(string $rfcUuidString) : static\n    {\n        if (preg_match(pattern: '\/^[[:xdigit:]]{8}-([[:xdigit:]]{4}-){3}[[:xdigit:]]{12}$\/', subject: $rfcUuidString) !== 1) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not a valid RFC Uuid string\");\n        }\n        $hexaString = str_replace(search: '-', replace: '', subject: $rfcUuidString);\n        $binaryString = hex2bin(string: $hexaString);\n        $bytes = str_split(string: $binaryString);\n        $bytes = array_map(callback: fn(string $byte) => ord(character: $byte), array: $bytes);\n        $instance = (new ReflectionClass(static::class))->newInstanceWithoutConstructor();\n        if ($instance->getVersion() != $rfcUuidString[14]) {\n            throw new InvalidArgumentException(\"The string {$rfcUuidString} is not an UuidV{$instance->getVersion()} string\");\n        }\n        $instance->timeLowBytes = array_slice(array: $bytes, offset: 0, length: 4);\n        $instance->timeMidBytes = array_slice(array: $bytes, offset: 4, length: 2);\n        $instance->versionBits = ($bytes[6] & self::HIGHEST_4_BITS_MASK) >> 4;\n        $bytes[6] = $bytes[6] & self::LOWEST_4_BITS_MASK;\n        $instance->timeHighBytes = array_slice(array: $bytes, offset: 6, length: 2);\n        $bytes[8] = $bytes[8] & self::CLOCK_SEQ_HIGH_MASK;\n        $instance->clockSeqHighBits = $bytes[8];\n        $instance->clockSeqLowByte = $bytes[9];\n        $instance->nodeBytes = array_slice(array: $bytes, offset: 10, length: 6);\n        return $instance;\n    }\n    \/**\n     * Generates random bytes, with bytes being unsigned integers between 0 and 255\n     *\n     * @param int $numberOfBytes - how many bytes to generate\n     *\n     * @return int[] - array of integers in [0;255] of specified size\n     *\/\n    protected final function randomBytes(int $numberOfBytes) : array\n    {\n        $binaryString = random_bytes(length: $numberOfBytes);\n        return array_map(callback: fn(string $ascii) => ord(character: $ascii) | self::BYTE_MASK, array: str_split($binaryString));\n    }\n    \/**\n     * Removes overflowing bits from the given value\n     *\n     * @param int $value - the integer to clamp\n     *\n     * @return int - 8 lowest bits of the given value\n     *\/\n    private function clampToByte(int $value) : int\n    {\n        return $value & self::BYTE_MASK;\n    }\n    \/**\n     * Clamps the given integers to bytes, ensuring no invalid value is send from extending classes\n     *\n     * @param int[] $integers - the integers to turn to bytes\n     *\n     * @return array - 8 lowest bits of each given integer\n     *\/\n    private function clampToBytes(array $integers) : array\n    {\n        return array_map(callback: fn(int $value) => $this->clampToByte($value), array: $integers);\n    }\n    \/**\n     * Writes the given bytes in an hexadecimal string\n     *\n     * @param int[] $bytes - array of unsigned byte to write\n     *\n     * @return string - the bytes as an hexadecimal string\n     *\/\n    private function hexaStringFrom(array $bytes) : string\n    {\n        $bytesCount = count(value: $bytes);\n        $binaryString = pack(\"C{$bytesCount}\", ...$bytes);\n        return bin2hex(string: $binaryString);\n    }\n}","originalFilePath":"\/home\/arch\/src\/web-project\/clean-arch-example\/Domain\/Fields\/Identity\/Uuid.php","originalStartLine":235},"diff":"--- Original\n+++ New\n@@ @@\n     protected final function randomBytes(int $numberOfBytes) : array\n     {\n         $binaryString = random_bytes(length: $numberOfBytes);\n-        return array_map(callback: fn(string $ascii) => ord(character: $ascii) & self::BYTE_MASK, array: str_split($binaryString));\n+        return array_map(callback: fn(string $ascii) => ord(character: $ascii) | self::BYTE_MASK, array: str_split($binaryString));\n     }\n     \/**\n      * Removes overflowing bits from the given value","processOutput":""}]}